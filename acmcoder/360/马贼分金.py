# encoding=utf-8

import sys

'''
#  马贼分金

如果先手拿走ai，那么先手可以得到的最大的价值是：
a(i) + sum(i + 1, j) - f(i + 1, j) => sum(i, j) - f(i + 1, j)
因为先手拿走a(i)后，后手就会在i + 1, j中取元素，因此双方都要按照最佳的策略取，因此后手也会在ai+1, ... aj的序列上取得最大值，这个时候我们可以把在ai, ai+1, ... aj上的后手看做在i + 1, ...j上的先手能取得最大的价值。

同理，如果先手拿走aj，那么先手可以得到的最大的价值是：
a(j) + sum(i, j - 1) - f(i, j - 1) => sum(i, j) - f(i, j - 1)

由此我们推出状态转移方程：
f(i, j) = max{sum(i, j) - f(i + 1, j), sum(i, j) - f(i, j - 1)}
=>
f(i, j) = sum(i, j) - min{f(i + 1, j), f(i, j - 1)}
0 <= i <= j <= L
其中L表示序列的总长度
f(i, j) = sum(i, j) 当 i == j时

最后，关于sum(i, j)的计算其实不需要使用二维数组来存储，因此这样非常浪费存储空间，类似的存储通常会采用下列的方式：
sum'(k)表示从数列开始(通常建议从1开始)到k位置的所有的元素的和
sum'(k) = sum'(k - 1) + a[k] (k >= 1, sum'[0] = 0_
那么sum(i, j) = sum'(j) - sum'(i - 1) (i >= 1)

通常，动态规划的代码都比较简短，其关键是分析问题，抽象模型，划分阶段，设计状态和决策。
'''

def golds():
    for k in range(1,input()+1):
        n=input()
        golds=[int(i) for i in raw_input().split(' ')]
        dp=[[0]*n for i in range(n)]
        sum=[0]*(n+1)
        for i in range(n):
            dp[i][i]=golds[i]
            sum[i+1]=sum[i]+golds[i]

        for j in range(1,n-1):
            for i in range(n-j):
                dp[i][i+j]=sum[i+j+1]-sum[i]-min(dp[i+1][i+j],dp[i][i+j-1])
        if dp[1][-1] > dp[0][-2]:
            print "Case# %d:"%k,sum[-1]-dp[0][-2], dp[0][-2]
        else:print "Case# %d:"%k,sum[-1]-dp[1][-1],dp[1][-1]


def goldAnswer():
    # 使用最小最大形式的求法，就可以用存sum，但是非常容易错
    while 1:
        line = sys.stdin.readline().strip()
        if not line:
            break

        T = int(line)
        for x in xrange(1,T + 1):
            n = int(sys.stdin.readline().strip())
            golds = map(int,sys.stdin.readline().strip().split())

            if n % 2 == 0:
                dp = [[0 for i in xrange(n)] for j in xrange(n)]
                for i in xrange(n - 1,-1,-1):
                    for j in xrange(i,n):
                        if i != j:
                            if(j - i) % 2 == 1:
                                dp[i][j] = max(dp[i + 1][j] + golds[i],dp[i][j - 1] + golds[j])
                            else:
                                dp[i][j] = min(dp[i + 1][j],dp[i][j - 1])

            else:
                dp = [[golds[i] if i == j else 0 for i in xrange(n)] for j in xrange(n)]
                for i in xrange(n - 1,-1,-1):
                    for j in xrange(i,n):
                        if i != j:
                            if(j - i) % 2 == 1:
                                dp[i][j] = min(dp[i + 1][j],dp[i][j - 1])
                            else:
                                dp[i][j] = max(dp[i + 1][j] + golds[i],dp[i][j - 1] + golds[j])

            print "Case #%d: " % x + str(dp[0][n - 1]) + " "  + str(sum(golds) - dp[0][n - 1])

'''
4
416
4 431 139 771 737 541 61 739 209 878 243 198 149 26 987 445 522 837 718 124 859 549 550 248 541 243 23 454 27 494 480 358 443 317 940 199 112 355 220 172 305 279 951 80 714 533 181 199 378 951 464 53 117 560 645 362 203 587 985 798 769 327 287 497 542 270 697 670 176 190 805 545 384 335 58 687 507 158 98 933 602 185 571 60 53 340 17 35 620 284 646 750 646 570 37 901 789 19 955 352 153 189 735 985 484 188 555 306 550 630 819 833 675 595 902 585 306 17 99 92 902 887 398 790 714 321 706 67 120 643 361 419 403 305 186 85 559 871 771 73 165 876 216 939 755 821 426 845 651 295 882 588 147 140 40 406 325 874 832 650 456 112 740 897 582 154 432 59 543 535 977 901 39 562 183 58 755 622 518 135 698 773 847 507 361 603 548 703 199 30 900 538 395 744 20 817 483 392 695 125 822 918 86 781 155 390 643 622 500 647 730 759 118 397 498 458 306 723 771 792 656 324 729 12 290 980 608 59 192 411 759 890 763 178 113 481 99 265 770 991 564 896 256 870 182 5 130 48 189 69 197 633 545 566 388 511 942 148 712 48 398 107 665 123 413 61 787 82 822 595 765 990 741 721 390 163 228 478 296 509 434 329 721 195 848 530 744 707 830 160 21 983 622 807 244 823 38 893 708 743 572 524 387 601 733 130 140 646 727 967 571 538 680 775 416 525 383 498 147 897 417 816 559 912 214 416 586 614 421 194 115 400 197 468 117 971 998 714 619 103 679 290 92 757 481 335 458 215 28 948 741 608 153 35 61 660 359 270 568 585 954 302 657 69 377 274 762 705 439 955 115 167 684 837 715 953 676 288 198 938 265 168 695 528 165 322 368 594 378 977 96 518 317 903 621 775 392 367 851 341 176 683 787 245 478 433 855 603 17 36 628 373 172 416 969 506
28
605 960 930 350 112 794 823 406 879 936 157 586 67 239 806 776 83 971 290 325 406 952 117 241 97 149 816 359
146
10 85 840 628 491 893 490 525 382 140 493 388 473 632 903 38 271 261 793 763 645 333 90 356 167 830 762 576 33 572 337 856 59 737 840 255 28 554 80 30 66 500 675 247 209 158 888 840 547 489 226 146 423 718 235 83 524 238 213 769 727 256 914 544 379 630 252 773 505 761 999 716 81 399 654 159 528 241 379 840 994 506 523 777 561 797 57 426 230 534 746 251 320 796 265 411 259 325 52 520 499 907 191 103 449 725 191 182 221 1 353 376 28 720 348 89 492 771 917 658 822 373 890 24 307 433 632 392 11 845 360 254 761 230 736 286 683 831 423 954 720 796 315 518 91 236
118
632 519 383 541 859 859 35 691 206 289 949 318 233 202 143 49 784 684 981 474 27 854 996 4 772 866 68 671 611 644 85 391 542 123 689 723 541 390 497 647 734 345 675 763 108 192 561 205 109 67 485 149 356 290 892 504 52 371 801 591 198 178 996 248 613 888 522 853 256 255 430 932 968 356 16 704 930 366 677 829 47 815 384 801 346 577 656 9 794 890 825 146 97 739 87 681 988 109 793 157 755 85 434 476 83 682 694 243 419 132 459 210 300 543 861 838 965 625


1
6
4 7 2 9 5 2
'''

if __name__ == '__main__':
    # goldAnswer()
    golds()

